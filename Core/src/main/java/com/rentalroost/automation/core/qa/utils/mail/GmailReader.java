package com.rentalroost.automation.core.qa.utils.mail;import java.io.IOException;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.Properties;import javax.mail.Flags;import javax.mail.Flags.Flag;import javax.mail.Folder;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Multipart;import javax.mail.Part;import javax.mail.Session;import javax.mail.Store;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.search.AndTerm;import javax.mail.search.SearchTerm;import javax.mail.search.SubjectTerm;import org.testng.Reporter;import com.sun.mail.imap.IMAPFolder;/** *  * @author kaushik_vira *  *  */public class GmailReader {	private static final String INBOX2 = "Inbox";	private static final String ARCHIVE2 = "Archive";	private static final String IMAP_GMAIL_COM = "imap.gmail.com";	private static final String IMAPS = "imaps";	private static final String MAIL_STORE_PROTOCOL = "mail.store.protocol";	public static void main(String args[]) throws IOException, InterruptedException {		String toEmailAddress = "ipn.automation+qu_3327485@gmail.com";		String timeout = "10";		boolean isArchive = false;		String gmailUser = "ipn.automation@gmail.com";		String gmailPassword = "automation!@#";		String subjectPattern = null;		boolean waitForAllEmailsTillTimeout = false;		GmailReader i = new GmailReader();	 List hi1 =	i.retriveEmail(toEmailAddress, subjectPattern, timeout, waitForAllEmailsTillTimeout, isArchive, gmailUser, gmailPassword);	 	 System.out.println(hi1.size() );		// i.retriveEmail(toEmailAddress, subjectPattern, timeout,		// waitForAllEmailsTillTimeout, isArchive, gmailUser, gmailPassword);	 	 	 List hi2 =	i.retriveCCEmail(toEmailAddress, subjectPattern, timeout, waitForAllEmailsTillTimeout, isArchive, gmailUser, gmailPassword);	 	 System.out.println(hi2.size());	}	public List<SimpleEmailMessage> retriveEmail(String toEmailAddress, String subjectPattern, String timeout, boolean waitForAllEmailsTillTimeout, boolean isArchive, String gmailUser, String gmailPassword) {		Reporter.log("Finding emails sent to : " + toEmailAddress);		Properties props = new Properties();		props.setProperty(MAIL_STORE_PROTOCOL, IMAPS);		try {			Session session = Session.getDefaultInstance(props, null);			Store store = session.getStore(IMAPS);			store.connect(IMAP_GMAIL_COM, gmailUser, gmailPassword);			IMAPFolder inbox = openInbox(isArchive, store);			SearchTerm term = defineTheTOSearchTerm(toEmailAddress, subjectPattern);			Message messages[];			Date date = new Date();			messages = searchEmailFromInbox(timeout, waitForAllEmailsTillTimeout, inbox, term, date);			List<SimpleEmailMessage> responseEmailList = new ArrayList<SimpleEmailMessage>();			if (messages != null) {				for (Message message : messages) {					responseEmailList.add(simplifyEmail(message));					if (isArchive) {						archiveMail(store, inbox, messages, message);					}				}			} else {				Reporter.log("no mail found");			}			store.close();			return responseEmailList;		} catch (Throwable e) {			throw new RuntimeException("Unable to read Email message");		}	}    public List<SimpleEmailMessage> retriveCCEmail(String ccEmailAddress, String subjectPattern, String timeout, boolean waitForAllEmailsTillTimeout, boolean isArchive, String gmailUser, String gmailPassword) {		Reporter.log("Finding emails sent to : " + ccEmailAddress);		Properties props = new Properties();		props.setProperty(MAIL_STORE_PROTOCOL, IMAPS);		try {			Session session = Session.getDefaultInstance(props, null);			Store store = session.getStore(IMAPS);			store.connect(IMAP_GMAIL_COM, gmailUser, gmailPassword);			IMAPFolder inbox = openInbox(isArchive, store);			SearchTerm term = defineTheCCSearchTerm(ccEmailAddress, subjectPattern);			Message messages[];			Date date = new Date();			messages = searchEmailFromInbox(timeout, waitForAllEmailsTillTimeout, inbox, term, date);			List<SimpleEmailMessage> responseEmailList = new ArrayList<SimpleEmailMessage>();			if (messages != null) {				for (Message message : messages) {					responseEmailList.add(simplifyEmail(message));					if (isArchive) {						archiveMail(store, inbox, messages, message);					}				}			} else {				Reporter.log("no mail found");			}			store.close();			return responseEmailList;		} catch (Throwable e) {			throw new RuntimeException("Unable to read Email message");		}	}	/**	 * @param timeout	 * @param inbox	 * @param term	 * @param date	 * @throws MessagingException	 * @throws InterruptedException	 */	private Message[] searchEmailFromInbox(String timeout, boolean waitForAllEmailsTillTimeout, IMAPFolder inbox, SearchTerm term, Date date) throws MessagingException, InterruptedException {		Message[] messages = null;		Long timeoutInms = new Long(timeout) * 1000;		if (waitForAllEmailsTillTimeout) {			System.out.println("waitForAllEmailsTillTimeout - True,  Thread sleep" + timeoutInms);			Thread.sleep(timeoutInms);			messages = inbox.search(term);		} else {			System.out.println("waitForAllEmailsTillTimeout - False");			do {				messages = inbox.search(term);				if (messages == null || messages.length == 0) {					if (new Date().getTime() - date.getTime() > timeoutInms) {						System.out.println("break");						break;					}					System.out.println("polling");					Thread.sleep(1000L);				}			} while (messages == null || messages.length == 0);		}		return messages;	}	/**	 * @param isArchive	 * @param store	 * @return	 * @throws MessagingException	 */	private IMAPFolder openInbox(boolean isArchive, Store store) throws MessagingException {		IMAPFolder inbox;		inbox = (IMAPFolder) store.getFolder(INBOX2);		if (isArchive) {			inbox.open(Folder.READ_WRITE);		} else {			inbox.open(Folder.READ_ONLY);		}		return inbox;	}	/**	 * @param toEmailAddress	 * @param subjectPattern	 * @return	 * @throws AddressException	 */	private SearchTerm defineTheTOSearchTerm(String toEmailAddress, String subjectPattern) throws AddressException {		SearchTerm term;		if (subjectPattern == null) {			term = new ToTerm(new InternetAddress(toEmailAddress));		} else {			term = new AndTerm(new ToTerm(new InternetAddress(toEmailAddress)), new SubjectTerm(subjectPattern));		}		return term;	}    /**	 * @param ccEmailAddress	 * @param subjectPattern	 * @return	 * @throws AddressException	 */	private SearchTerm defineTheCCSearchTerm(String ccEmailAddress, String subjectPattern) throws AddressException {		SearchTerm term;		if (subjectPattern == null) {			term = new ToTerm(new InternetAddress(ccEmailAddress));		} else {			term = new AndTerm(new CCTerm(new InternetAddress(ccEmailAddress)), new SubjectTerm(subjectPattern));		}		return term;	}	/**	 * @param message	 * @return	 * @throws MessagingException	 * @throws IOException	 */	private SimpleEmailMessage simplifyEmail(Message message) throws MessagingException, IOException {		SimpleEmailMessage email = new SimpleEmailMessage();		email.setFrom(InternetAddress.toString(message.getFrom()));		email.setReplyTo(InternetAddress.toString(message.getReplyTo()));		email.setTo(InternetAddress.toString(message.getRecipients(Message.RecipientType.TO)));		email.setSubject(message.getSubject());		email.setSentDate(message.getSentDate());		Object content = message.getContent();		StringOutputStream writer = new StringOutputStream();		if (content instanceof Multipart) {			handleMultipart((Multipart) content, writer);						List<String> fileNameList = new ArrayList<String> ();						Multipart acttachmentContent = (Multipart) content;			for (int i = 0, n = acttachmentContent.getCount(); i < n; i++) {				fileNameList.add(acttachmentContent.getBodyPart(i).getFileName());				email.setFileName(fileNameList);			}				}		email.setBodyContent(writer.toString());		writer.close();		return email;	}	/**	 * @param store	 * @param inbox	 * @param messages	 * @param message	 * @throws MessagingException	 */	private void archiveMail(Store store, IMAPFolder inbox, Message[] messages, Message message) throws MessagingException {		if (!store.getFolder(ARCHIVE2).exists()) {			store.getFolder(ARCHIVE2).create(Folder.HOLDS_MESSAGES);		}		IMAPFolder archive = (IMAPFolder) store.getFolder(ARCHIVE2);		inbox.copyMessages(messages, archive);		message.setFlag(Flags.Flag.DELETED, true);	}	private void handleMultipart(Multipart multipart, StringOutputStream writer) throws MessagingException, IOException {		for (int i = 0, n = multipart.getCount(); i < n; i++) {			handlePart(multipart.getBodyPart(i), writer);		}	}	private void handlePart(Part part, StringOutputStream writer) throws MessagingException, IOException {		String disposition = part.getDisposition();		String contentType = part.getContentType();		if (disposition == null) { // When just body			// Check if plain			if ((contentType.length() >= 10) && (contentType.toLowerCase().substring(0, 10).equals("text/plain"))) {				part.writeTo(writer);			} else { // Don't think this will happen				part.writeTo(writer);			}		}	}		public boolean cleanUpEmailInbox(String timeout, boolean waitForAllEmailsTillTimeout, boolean isArchive, String gmailUser, String gmailPassword) {				Store store = null;		Properties props = new Properties();		props.setProperty(MAIL_STORE_PROTOCOL, IMAPS);		try {			Session session = Session.getDefaultInstance(props, null);			store = session.getStore(IMAPS);			store.connect(IMAP_GMAIL_COM, gmailUser, gmailPassword);			IMAPFolder inbox = openInbox(isArchive, store);			Message messages[];			messages = inbox.getMessages();			List<SimpleEmailMessage> responseEmailList = new ArrayList<SimpleEmailMessage>();			int msgCounter = 0;				for (Message message : messages) {					message.setFlag(Flags.Flag.SEEN, true);				responseEmailList.add(simplifyEmail(message));					if (isArchive) 					{						archiveMail(store, inbox, messages, message);						msgCounter ++;					}				}			if (msgCounter == messages.length)				return true;						return false;		} catch (Throwable e) {			throw new RuntimeException("Unable to read Email message");		}		finally {			try {				store.close();			} catch (MessagingException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}	}}